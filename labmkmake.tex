\labwork{Создание Makefile}\label{labmkmake}

Стоит объяснить, почему при создании проекта мы выбрали тип \file{Makefile
project}, хотя были доступны более логичные варианты типа \file{ARM C Project}.

Утилита \make\ ведет свою историю с 70х гг. Компьютеры тогда были большими,
тяжелыми, а главное медленными и с очень маленькой памятью (десятки$\div$сотни
Кб).
Компиляторам зачастую не хватало памяти, чтобы скомпилировать большую программу.
Кроме того, скорость их запуска и работы была тоже черепашьей.
Поэтому исходный код программы делили на модули, компилировали или
ассемблировали каждый модуль по-отдельности в \term{объектный код}, а затем уже
на конечном этапе с помощью \term{линкера}\ собирали несколько файлов объектного
кода в один исполнямый файл.

Для ускорения и упрощения этого процесса и была создана утилита \make.
Чтобы не вызывать лишний раз компилятор или какой-нибудь транслятор, в файле
\makefile\ прописываются зависимости между файлами. Затем запускается \make\ c
указанием какой файл нам нужно получить, и выполняется цепочка вызовов нужных
программ.

Следует отметить, что утилита \make\ используется до сих пор для сборки самых
современных программных пакетов\footnote{типа GCC 4.9.x, ядра Linux или KDE под
FreeBSD}, правда в комплексе с другими средствами, обеспечивающими переносимость
программ между разными ОС и автогенерацией зависимостей из исходного кода.

\bigskip 
Для наших целей \make\ используется как самое простое средство
управления компиляцией проекта. В средах разработки, особенно в коммерческих,
используются служебные файлы проектов, иногда бинарные, чаще текстовые, но
всегда запутанные и весьма развесистые.

Если вам вдруг понадобится откомпилировать ваш проект на другом компьютере, с
другой архитектурой, возможно вообще без графического
интерфейса\footnote{например какой-нибудь удаленный сервер на процессоре
1995ВМ666 под раскряченным Solaris 7$\alpha$4, на котором лежит
криптобиблиотека, использующая при компиляции трофейный электро-механический
энкодер, существующий в единственном экземпляре \smiley}, или вы вдруг решите
попробовать работать в другой IDE\ --- вы тут же вляпаетесь в ситуацию, когда
нечем открыть файл проекта с заботливо прописанными опциями компиляции.

\bigskip
\menu{\eclipse>\window{Project Explorer}>\file{hello}>\rms>Open Project}

\menu{\eclipse>\window{Project Explorer}>\file{hello}>\rms>New>File>File
name:>\file{Makefile}}

\bigskip
\lstinputlisting[style=mk,inputencoding=cp1251]{tmp/hello.mk}

\alarm{Обратите внимание, особенно если не используете \eclipse\ --- текстовый
редактор должен быть настроен так, чтобы символ табуляции} \verb|<TAB>|
\alarm{не заменялся на пробелы, и отображался как 4} \verb|<пробел>|а.
\alarm{В листинге табуляции специально выделены, т.к. \emph{имеют синтаксическое
значение}}.

\bigskip
Этот пример \makefile\ достаточно универсален и самодостаточен для большинства
проектов в этой книге. Кажущийся большой объем получился за счет использования
комментариев и переменных. И те, и другие служат для документирования проекта,
и повышают читаемость кода. В принципе никто не мешает\footnote{особенно для
микроскопических объемов исходных текстов программ для контроллеров\ ---
в самом худшем случае какие-то жалкие сотни Кб}\ написать несколько строк в
\file{.bat}нике с явным указанием опций компиляторам, или вообще откомпилировать
все исходники сразу одним вызовом \file{gcc}\ с кучей опций и списком исходных
файлов. Но если вам потребуется что-то изменить, куда проще и быстрее сделать
это в аккуратно оформленном самодокументированном \makefile.

\bigskip
  Компилятор преобразует программу на языке программирования высокого уровня
  \footnote{для микроконтроллерных встраиваемых систем используются Си и \cpp,
  на более тяжелых процессорах типа Cortex-Ax свободно применяются Java,
  Fortran, Python, и еще стопиццот языков, созданных за последние 50 лет истории
  IT}\ в \term{объектный код} (смесь кусочков машинного кода со служебной
  информацией) или в текст на языке ассемблера.
  
  \term{Кросс-компилятор}\ (\file{gcc}) отличается от обычного
  компилятора тем, что генерирует код не для компьютера на котором он
  выполняется (\term{хост-система}, \verb|$HOST|), а для компьютера другой
  архитектуры\ --- \term{целевой системы}, \verb|$TARGET|.
  
  \term{Ассемблер}\ (\file{as}) преобразует человекочитаемый машинный код
  программы в объектный код.
  
  \term{Линкер}\ (\file{ld}) объединяет несколько файлов объектного кода в один,
  и корректирует машинный код с учетом его конечного размещения в памяти целевой
  системы (адреса переменных, адреса переходов, размещение сегментов кода и
  данных в физической памяти целевой системы).
  
  \term{Дампер}\ (\file{objdump}) позвляет получить информацию о содержимом
  объектных файлов, в частности значения различных служебных полей, и
  дизассемблированный машинный код. 
  
  \term{Копир}\ (\file{objcopy}) преобразует сегменты кода/данных из файла,
  полученного линкером, в формат, необходимый для ПО программатора: бинарные
  файлы, Intel HEX, ELF,.. загружаемые в масочное ПЗУ, FlashPROM (и EEPROM
  данных на МК ATmega).
  
  \bigskip
  Так как часто разработчики встраиваемых систем работают
  с разными аппаратными платформами, для команд тулчайна
  принято использовать префиксы типа \file{arm-none-eabi-},
  чтобы явно отличать, какой именно (кросс-)компилятор вызывается.
  
  \bigskip
  Главная синтаксическая конструкция \makefile\ --- блок правила, задающий
  зависимость между файлами и набор команд, которые нужно выполнить, если 
  \textbf{дата
  модификации файла-цели старее, чем дата модификации одного из
  файлов-источников}. То есть если вы измените какой-то из файлов проекта,
  начнут срабатывать правила, которые обновляют завимимые от него файлы.

  Синтаксис:
  
\begin{verbatim}
<файл-цель>: [<файл-источник1> ...]
[<tab><команда1>]
[<tab><команда2>]
[...]
\end{verbatim}

Количество файлов-источников и команд может быть любое, в том числе и нулевое.
Каждая команда правила отбивается слева одной табуляцией (один символ с кодом
\verb|0x09|, \alarm{не пачка пробелов}). \alarm{Будьте аккуратны, редактируя
\makefile\ во всяких блокнотах, вордпадах и прочей ереси, любящей
``оптимизировать'' пробелы: истинный TAB и 4 пробела на экране, как завещал
Великий Столлман}.

Использование переменных особых комментариев не требует, обычная подстановка.
Есть переменная \verb|$@|, имеющая значение текущего файла-цели. Есть похожая
переменная \verb|$<|\ --- имя первого файла-источника.

Если кто вдруг не знает\ --- символ \verb|>|\ в командной строке применяется для
перенаправления текстового вывода любой команды в файл. Если нужно в одной
строке выполнить последовательно несколько команд, используются маркеры
сцепления \verb|;|\ \verb|&&| и \verb$|$. Описание их применения см. любую
книжку по UNIX детсадовского уровня. В \makefile\ для простого
последовательного выполнения команд\footnote{без передачи данных через потоки
ввода/вывода}\ рекомендуется использовать сцепку \verb|&&|\footnote{следующие
команды выполнятся только если предыдущая завершилась без ошибок\ --- если
компиляция завершится ошибкой, незачем вызывать программатор}.

Команды выполняются с синтаксисом: 
\verb|<[путь]команда[.exe]> [параметры через пробел]|.

Команда\ --- имя выполняемого файла, может указываться с полным путем (диск,
цепочка каталогов) или без. Если путь не указан, поиск выполняемого файла
проводится в списке каталогов, заданном в системной перемененной \verb|$PATH|.
Под DOS и Windows исполняемые файлы имеют суффикс \verb|.exe|, \verb|.bat| и
\verb|.com|, который в командной строке обычно не указывается. Под UNIX флаг
выполнимости можно поставить вообще на любой файл.

В параметрах указываются имена файлов и опции: текстовые одно- и многобуквенные
имена, начинающиеся с одинарного или двойного минуса. Параметры разделяются
одним или несколькими пробелами. Порядок и значение параметров зависит от
команды. Параметры для команд GNU toolchain и ПО программаторов подробно описаны
далее.

\bigskip
\alarm{Под Windows x64 обнаружилась большая проблема\ --- если в
\makefile\ используется перенаправление вывода команды в файл типа}
\verb|objdump -xd program.o > program.o.dump| \alarm{ или маркеры сцепления, при
выполнении
\file{make} завершается с ошибкой }
\verb|make: Interrupt/Exception caught| \verb|(code = 0xc00000fd,|
\verb|addr = 0x4227d3)|
\alarm{. Решение пока не найдено, а анализировать получившийся машинный
код нужно, поэтому была написана программа-затычка \file{fix64}, запускающая
\file{arm-none-eabi-objdump} с перенаправлением вывода в файл.}
