# пример мейкфайла для проекта Азбука ARMатурщика
# лабораторная работа ЛР{labmkmake}
# символ # в начале -- комментарий

# пример использования переменных

# простое присваивание значения переменной
# обнуление переменной
SOMEVAR =
# маски временных файлов
TMPFILES = *.o *.hex *.dump

# целевая платформа $TARGET, часто называют "префикс целевой платформы"
TARGET = arm-none-eabi
# целевой процессор
CPU = cortex-m3
CPUOPT = -mcpu=$(CPU) -mthumb
# целевой процессор для запуска под gdb-симулятором ARM7TDMI
CPU = arm7tdmi
CPUOPT = -mcpu=$(CPU) 

# присваивание переменной с подстановкой значений другой переменной
# стандартные переменные, задающие команды ассемблера, компилятора и линкера 
AS = $(TARGET)-as
CC = $(TARGET)-gcc
LD = $(TARGET)-ld
OBJDUMP = fix64.exe
# $(TARGET)-objdump
OBJCOPY = $(TARGET)-objcopy
MAKE = make

# нестандартная (?) переменная - опции оптимизации
OPTFLAGS = -O0
# опции генерации отладочной информации
DEBFLAGS = -g3 -ggdb
# стандартная переменная - флаги компилятора Си
CFLAGS  = $(CPUOPT) $(OPTFLAGS) $(DEBFLAGS)
# флаги ассемблера
ASFLAGS = $(CPUOPT) $(DEBFLAGS)

# указание что цели all и clean являются фиктивными целями, а не файлами
.PHONY: all clean

# первая цель, заданная в Makefile, является целью по умолчанию
# и обрабатывается при вызове $(MAKE) без параметров

# стандартная цель, предусматривающая сборку всего проекта 
all: fix64.exe startup.o init.o main.o

# сборка затычки для x64 систем, требует установленный пакет MinGW
fix64.exe: fix64.c
	gcc -o $@ $<

# стандартная цель, удаление всех временных и конечных бинарных файлов
clean:
	rm -f $(TMPFILES)

# макро-правило: как компилировать сишные файлы в объектный код
# вместо % в других правилах могут подставляться любые символы, см. цель all
# тэг $@ заменяется на цель правила, т.е. %.o
# тэг $< заменяется на первый источник, т.е. %.с
%.o: %.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $<
	$(OBJDUMP) -dx $@

# макро-правило: как компилировать ассемблерные файлы
//ASFLAGS = 
%.o: %.S Makefile
	$(AS) $(ASFLAGS) -o $@ $<
	$(OBJDUMP) -dx $@
