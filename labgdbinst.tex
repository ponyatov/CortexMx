\labwork{Настройка отладчика в \eclipse}\label{labgdbinst}

\cp{http://makesystem.net/?p=2146}

 На сегодняшний день существуют много способов и инструментов для отладки
 embedded приложений, начиная с отладки “в железе” (внутрисхемная отладка)  и
 заканчивая всякими симуляторами. У каждого метода есть свои плюсы и минусы, но
 поскольку мы будим писать приложения для реальных устройств, то
 предпочтительней реальная отладка (в железе), то есть приложение будит
 исполняться непосредственно микроконтроллером.
 
Что нам понадобится для “железной отладки” :

\begin{itemize}
  \item 
ARM микроконтроллер (для симуляции необязателен)
  \item 
JTAG/SWD адаптер (для симуляции необязателен)
  \item 
GDB сервер (транслятор интерфейсов GDB/JTAG)
  \item 
GDB отладчик (имеет встроенный симулятор ARM7TDMI, используется для первых лаб) 
  \item 
плагин C/C++ GDB Hardware Debugging 
  \item 
плагин Eclipse Embedded Systems Register View 
\end{itemize}

\term{JTAG адаптер}\ (он же \term{программатор}) следует выбрать тот, который
поддерживает именно ваш микроконтроллер, а еще лучше, микроконтроллеры разных
производителей.
В моем случае (еще с давних времен у меня завалялись кристаллы от Texas
Instruments, ST Microelectronics, NXP, Atmel, Cypress), я сразу решил найти
программатор поддерживающий имеющиеся у меня камни. Порыскав в интернетах, мой
выбор пал на китайский клон знаменитого J-Link, в добавок к которому идет уйма
полезных утилит от Segger Microcontroller (тут обошлось без китая \smiley),
облегчающие жизнь разработчику.

В этой книге также рассмотрено несколько простых варинтов JTAG-адаптеров,
которые вы можете сделать сами, не обладая выдающимися знаниями в электронике
и технологиях производства печатных плат.

\bigskip
Структура аппаратно-программного комплекта для отладки:

\menu{микроконтроллер>JTAG/SWD>адаптер>LPT/USB>GDB сервер>протокол
GDB>GDB отладчик>IDE}

Адаптер подключается к выводам МК с помощью колодки (JTAG) или гребенки (SWD).

К компьютеру адаптер подключается через однин из распространенных интерфейсов:
совсем дешевые варинты ``на пяти резисторах'' через порт LPT, чуть подороже
через USB, совсем дорогие проф.модели могут иметь Ethernet интерфейс.

\bigskip
\term{Отладчик}\ (дебаггер, англ. debugger)\ --- компьютерная программа,
предназначенная для поиска ошибок в других программах. Отладчик позволяет
выполнять пошаговую трассировку, отслеживать, устанавливать или изменять
значения переменных в процессе выполнения кода, устанавливать и удалять
контрольные точки или условия остановки, сопоставлять двоичный код\ --- eгo
исходному тексту (на основе которых можно точно определить выполняемые
программой действия) и т.д. (Wiki)

Практически во все тулчейны входит утилита GDB (\file{arm-none-eabi-gdb}), это и
есть отладчик GNU. В принципе, дебаггер выполняет два типа действий:
управление исполнением программы в кристалле (через отладочный интерфейс) и
вывод результатов в консоль/графическую оболочку.

\bigskip
При сборке тулчайна (из исходников) невозможно заранее сказать, какой набор
отладочных средств будет у конечного пользователя\ --- у типичного
ембеддера\footnote{разработчика ПО под встраиваемые системы}\ запросто наберется
пара-тройка различных \jtag-адаптеровв, несколько демоплат со
встроенным адаптером, причем с разными процессорами, несколько собственных
устройств с самодельными отладочными интерфейсами, и еще для комплекта пару
чисто программных симуляторов \arm-ядер.

Задачу унификации интерфесов, и подключения всего этого зоопарка к одному и тому
же отладчику \gdb\ выполняет \term{\gdb-сервер}. Отладчик общается с сервером по
одному и тому же унифицированному \term{\gdb-протоколу}\ через последовательный
порт или TCP/IP соединение, а все сложности взаимодействия с железом берет на
себя сервер.
Это сделано (в том числе) для тех случаев, когда \gdb-отладчик работает на одном
ПК а \gdb-сервер на другом (в соседней комнате или соседнем государстве
\smiley). Опять же, сервер надо выбрать тот, который поддерживает ваш
\jtag-адапер или эмулятор.

\bigskip
\gdb, как и все остальные утилиты тулчайна, работает из командной строки, что
не всем удобно \smiley, поэтому для начала стоит научиться им пользоваться из
графической оболочки. \eclipse\ как и подобает серьёзной IDE, имеет средства
работы с \gdb, заменяющие его консоль, имеет графические кнопки для вызова
всех отладочных команд, и отображает содержимое регистров, памяти и т.п. в
графических окнах. Взаимодействие \eclipse/\gdb\ обеспечивает плагин \file{C/C++
GDB Hardware Debugging}, входящий в состав уже установленного ранее
расширения \file{CDT}.

\bigskip
Проверить наличие плагина можно так:

\menu{Help>Install New Software>Work with:>All Available Sites}

\menu{\uncheckbox\ Hide items that are already installes}

\menu{type filter>GDB}

\dirtree{%
.1 GDB.
.2 CDT Optional Features.
.3 \checkbox\ C/C++ GDB Hardware Debugging.
.2 Mobile and Device Development.
.3 \checkbox\ C/C++ GDB Hardware Debugging.
}

\bigskip

Прежде всего отключим оптимизацию кода проекта, задав в
\makefile\ значение переменной \file{OPTFLAGS = -O0}. 

Затем, нужно включить в проекте генерацию отладочной информации\footnote{имена
переменных, функций и т.п. объектов программы, в т.ч. и сами строки исходного
кода}, добавив опцию \file{-g[N]}.

Существуют три уровня отладочной информации:

\begin{enumerate}
\item в объектный код вставляется минимальный объем отладочной информации. Ее
вполне достаточно для трассировки вызовов функций и исследования глобальных
переменных, тем не менее, отсутствует информация для сопоставления выполняемого
кода со строками исходного кода и информация для отслеживания локальных
переменных.

\item используется по умолчанию. Помимо всей отладочной информации пepвoгo
уровня он дополнительно включает данные, необходимые для сопоставления строк
исходного кода с выполняемым кодом, а также имена и расположение локальных
переменных.

\item помимо всей отладочной информации пepвoгo и второго уровней, включает
дополнительную информацию, в частности определения макросов препроцессора.
\end{enumerate}

Используем 3 уровень, изменив в \makefile\ значение переменной 
\file{DEBFLAGS = -g3 -ggdb}. Опция \term{-ggdb}\ задает дополительно формат
отладочной информации. Доступны форматы STABS, DWARF2 и родной формат платформы.

В файле \file{startup.o.dump}\ при этом появляются дополнительные секции
с отладочной информацией, и в заголовок добавляются флаги, указывающие на
ее наличие:

\begin{lstlisting}[title=startup.o.dump]
startup.o:     file format elf32-littlearm
architecture: armv4t, flags 0x00000011: HAS_RELOC, HAS_SYMS
...
  4 .debug_line   00000044  00000000  00000000  000000b0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_info   00000044  00000000  00000000  000000f4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_abbrev 00000014  00000000  00000000  00000138  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000150  2**3
                  CONTENTS, RELOC, READONLY, DEBUGGING
\end{lstlisting}   

\bigskip
Для настройки отладочного интерфейса заходим в меню

\menu{Run>Debug Configurations\ldots}

\menu{GDB Hardware Debugging>\rms>New}

В результате открывается окно с настройками отладки.

\bigskip
Для начала попробуем работу нашей прошивки на встроенном в \gdb\ программном
симуляторе процессора \file{ARM7TDMI}.

\bigskip
Вкладка Main.

\bigskip
В поле Name, можно дать имя всей конфигурации отладки, поскольку даже для одного
проекта бывают разные конфигурации отладки (скажем для отладки в RAM или Flash
памяти).

\menu{Name:>ARM7TDMI simulator}

В поле Project указываем имя проекта (поскольку в нашем workspace может быть
более одного проекта)

\menu{Project:>hello}

В поле C/C++ Application указываем имя *.elf файла сгенерированного после
компиляции (с введенными ранее настройками для Debug прошивки) проекта и который
будет использован во время отладки.

\menu{C/C++ Application:>startup.o}

\alarm{Перед тем как перейти к следующей вкладке, в нижней части окна
обязательно выбираем}

\menu{Legacy GDB Hardware Debugging Launcher}

\menu{Apply}

\bigskip
Вкладка Debugger. Здесь мы установим связь между отладчиком и графической
оболочкой, а также между отладчиком и \gdb-сервером (отсюда и название вкладки).

\bigskip
В поле GDB Command указываем имя отладчика из тулчайна.
Должен быть прописан в \file{\$PATH}, или можно указать полный путь

\menu{GDB Command:>arm-none-eabi-gdb}

В соответствии с идеологией ведущих разработчиков Free Software Foundation,
\gdb\ вместо собственного графического пользовательского интерфейса
предоставляет возможность подключения к внешним IDE, управляющим графическим
оболочкам либо использовать стандартный консольный текстовый интерфейс” (Wiki).
В общем, mi (Machine Interface) это протокол общения между отладчиком и
графической оболочкой.

\menu{Command Set:>Standard (Windows)}

\menu{Protocol Version:>mi}

Как ранее было сказано, общение между отладчиком и сервером осуществляется через
последовательный или TCP/IP порт, поэтому в общем случае следует выбирать опции
типа:

\menu{Remote Target>\checkbox\ Use remote target}

\menu{JTAG Device:>Generic TCP/IP}

\menu{IP address:>localhost}

\menu{Port number:>12345}

\alarm{Но поскольку мы собираемся использовать встроенный симулятор ARM7,
пока нужно \textbf{выключить} удаленную отладку:}

\menu{\uncheckbox\ Use remote target}

\bigskip

\menu{Apply}

\bigskip
Вкладка Startup (предписания отладчику перед началом работы).

\bigskip
Сброс необходим для того чтобы очистить регистры ARM процессора от значений
полученных в ходе предыдущей отладки (по желанию)

\menu{Reset and Delay (seconds):>3}

Останавливаем процессор для настройки эмулятора и загрузки отлаживаемой прошивки

\menu{\checkbox\ Halt}

В (пустом) текстовом поле вводим команды, выполняемые при старте отладки.

\bigskip
Настало время вернутся к вопросу об использовании симуляции микроконтроллеров
\file{ARM7TDMI}. На самом деле с этой задачей запросто справляется сам \gdb,
если указать ему стартовые команды:

\menu{target sim}

\menu{load}

%monitor speed auto
%monitor endian little
%monitor flash device = STM32F103RB
%monitor flash download = 1
%monitor flash breakpoints = 1

Из какого файла грузить прошивку

\menu{Load image>Use project binary}

Из какого файла грузить отладочную информацию\footnote{можно использовать
отдельный \file{.sym} файл}

\menu{Load symbols>Use project binary}

\menu{Apply}

\bigskip
Вкладка Common

\bigskip

\menu{Display in favorites menu>\checkbox\ Debug}

\menu{Standard Input and Output>\checkbox\ Allocate console}

\menu{\checkbox\ Launch in background}

\menu{Apply}

% \bigskip
% Задача \gdb-сервера слушать последовательный или TCP/IP порт и перенаправлять
% команды \jtag-адаптеру, а он в свою очередь микроконтроллеру.
% 
% Поскольку мы уже указали отладчику использовать локальный TCP/IP порт
% \file{localhost:12345}, осталось указать серверу какой отладочный интерфейс
% использовать.

\bigskip
При первом запуске отладки, \eclipse\ просит разрешение на переход в режим
отображения отладки (Debug perspective). Разрешаем и ставим галку “\checkbox\
больше не спрашивать“. Далее, открывается отображение многочисленных окон,
каждое со своим предназначением (окна исходного кода, окно дизассемблера, окно
отображения памяти и т.д.). При желании можно добавить различные окна через меню
\menu{Window>Show View}.

\bigskip

Первый запуск отладчика \bug: \menu{кнопка клопа>ARM7TDMI simulator}

Последующие запуски (последнего) отладчика: просто \keys{F11} 

\bigskip
\begin{lstlisting}
symbol-file C:\\ARM\\book\\hello\\startup.o
Reading symbols from C:\ARM\book\hello\startup.o...done.
target sim
load C:\\ARM\\book\\hello\\startup.o 
Connected to the simulator.
Loading section .text, size 0x50 vma 0x0
Start address 0x0
Transfer rate: 640 bits in <1 sec.
\end{lstlisting}
