\chapter{Архитектура ARM}

\cp{\url{http://ru.wikipedia.org/wiki/ARM}} %\_(архитектура)

Архитектура ARM (Advanced RISC Machine, Acorn RISC Machine, 
усовершенствованная RISC-машина)\ --- семейство лицензируемых 32-битных и 
64-битных микропроцессорных ядер разработки компании ARM Limited.

Среди лицензиатов: практически все заметные разработчики цифровых
электронных компонентов.
Многие лицензиаты делают собственные версии ядер на базе ARM.

Значимые семейства процессоров: ARM7, ARM9, ARM11 и Cortex.

В 2007 году около 98\% из более чем миллиарда мобильных телефонов, продаваемых 
ежегодно, были оснащены по крайней мере одним процессором ARM. По состоянию 
на 2009 на процессоры ARM приходилось до 90\% всех встроенных 32-разрядных 
процессоров. Процессоры ARM широко используются в потребительской 
электронике\ --- в том числе КПК, мобильных телефонах, цифровых носителях и 
плеерах, портативных игровых консолях, калькуляторах и компьютерных п
ериферийных устройствах, таких как жесткие диски или маршрутизаторы.

Эти процессоры имеют низкое энергопотребление, поэтому находят широкое 
применение во встраиваемых системах и преобладают на рынке мобильных 
устройств, для которых данный фактор немаловажен.

В настоящее время значимыми являются несколько семейств процессоров ARM:

\begin{itemize}
\item ARM7 (с тактовой частотой до 60-72 МГц), предназначенные, например, для 
недорогих мобильных телефонов и встраиваемых решений средней производительности. 
В настоящее время активно вытесняется новым семейством Cortex.
\item ARM9, ARM11 (с частотами до 1 ГГц) для продвинутых телефонов, карманных 
компьютеров и встраиваемых решений высокой производительности.
\item Cortex A\ --- новое семейство процессоров на смену ARM9 и ARM11.
\item Cortex M\ --- новое семейство процессоров на смену ARM7, также 
призванное занять новую для ARM нишу встраиваемых решений низкой 
производительности. В семействе присутствуют три значимых ядра: \cm{0}, 
\cm{3} и \cm{4}.
\end{itemize}

\paragraph{Архитектура}

Существует спецификация архитектуры ARM Cortex, которая разграничивает все типы опций, 
которые поддерживает ARM, так как детали реализации каждого типа процессора м
огут отличаться. Архитектура развивалась с течением времени, и начиная с 
ARMv7 были определены 3 профиля:
\begin{itemize}
\item{A (application)} для устройств, требующих высокой производительности (смартфоны, планшеты)
\item{R (real time)} для приложений, работающих в реальном времени,
\item{M (microcontroller)} для микроконтроллеров и недорогих встраиваемых устройств.
\end{itemize}

\paragraph{Режимы процессора}

Процессор может находиться в одном из следующих рабочих режимов:
\begin{itemize}
\item{User mode} — обычный режим выполнения программ. В этом режиме 
выполняется большинство программ.
\item{Fast Interrupt (FIQ)} — режим быстрого прерывания (меньшее время с
рабатывания)
\item{Interrupt (IRQ)} — основной режим прерывания.
\item{System mode} — защищённый режим для использования операционной системой.
\item{Abort mode} — режим, в который процессор переходит при возникновении 
ошибки доступа к памяти (доступ к данным или к инструкции на этапе 
prefetch конвейера).
\item{Supervisor mode} — привилегированный пользовательский режим.
\item{Undefined mode} — режим, в который процессор входит при попытке 
выполнить неизвестную ему инструкцию.
\end{itemize}

Переключение режима процессора происходит при возникновении соответствующего 
исключения, или же модификацией регистра статуса.

\paragraph{Набор команд ARM}

Режим, в котором исполняется 32-битный набор команд.

\paragraph{Набор команд \thmod}

Для улучшения плотности кода процессоры, начиная с ARM7TDMI, снабжены режимом 
\thmod. В этом режиме процессор выполняет альтернативный набор 16-битных 
команд. Большинство из этих 16-разрядных команд переводятся в нормальные 
команды ARM. Уменьшение длины команды достигается за счет сокрытия некоторых 
операндов и ограничения возможностей адресации по сравнению с режимом полного 
набора команд ARM.

В режиме \thmod\ меньшие коды операций обладают меньшей функциональностью. 
Например, только ветвления могут быть условными, и многие коды операций имеют 
ограничение на доступ только к половине главных регистров процессора. Более 
короткие коды операций в целом дают большую плотность кода, хотя некоторые 
операции требуют дополнительных команд. В ситуациях, когда порт памяти или 
ширина шины ограничены 16 битами, более короткие коды операций режима 
\thmod\ становятся гораздо производительнее по сравнению с обычным 32-битным ARM 
кодом, так как меньший программный код придется загружать в процессор при 
ограниченной пропускной способности памяти.

Аппаратные средства типа Game Boy Advance, как правило, имеют небольшой объём 
оперативной памяти доступной с полным 32-битным информационным каналом. Но 
большинство операций выполняется через 16-битный или более узкий информационный 
канал. В этом случае имеет смысл использовать \thmod\ код и вручную 
оптимизировать некоторые тяжелые участки кода, используя переключение в 
режим \armod.

\paragraph{Набор команд \thmod2}

\thmod2 — технология, стартовавшая с ARM1156 core, анонсированного в 2003 
году. Он расширяет ограниченный 16-битный набор команд Thumb дополнительными 
32-битными командами, чтобы задать набору команд дополнительную ширину. Цель 
\thmod2\ --- достичь плотности кода как у Thumb, и производительности как у 
набора команд \armod\ на 32 битах. Можно сказать, что в ARMv7 эта цель была 
достигнута.

\thmod2 расширяет как команды \armod, так и команды \thmod\ ещё большим 
количеством команд, включая управление битовым полем, табличное ветвление, 
условное исполнение. Новый язык «Unified Assembly Language» (UAL) поддерживает 
создание команд как для ARM, так и для Thumb из одного и того же исходного 
кода. Версии \thmod\ на ARMv7 выглядят как код ARM. Это требует осторожности и 
использования новой команды if-then, которая поддерживает исполнение до 4 
последовательных команд испытываемого состояния. Во время компиляции в ARM 
код она игнорируется, но во время компиляции в код \thmod2 генерирует команды.

\paragraph{Набор команд Jazelle}

Jazelle — это технология, которая позволяет байткоду Java исполняться прямо 
в архитектуре ARM в качестве 3-го состояния исполнения (и набора команд) 
наряду с обычными командами ARM и режимом Thumb. Поддержка технологии Jazelle 
обозначается буквой «J» в названии процессора — например, ARMv5TEJ. Данная 
технология поддерживается начиная с архитектуры ARMv6, хотя новые ядра 
содержат лишь ограниченные реализации, которые не поддерживают аппаратного 
ускорения.

\paragraph{ARMv8 и набор команд ARM 64 бит}

В конце 2011 года была опубликована новая версия архитектуры, ARMv8. В ней 
появилось определение архитектуры AArch64, в которой исполняется 64-битный 
набор команд A64. Поддержка 32-битных команд получила название A32 и
 исполняется на архитектурах AArch32. Инструкции Thumb поддерживаются в 
 режиме T32, только при использовании 32-битных архитектур. Допускается 
 исполнение 32-битных приложений в 64-битной ОС, и запуск виртуализованной 
 32-битной ОС при помощи 64-битного гипервизора.[47] Applied Micro, AMD, 
 Broadcom, Calxeda, HiSilicon, Samsung, STM и другие заявили о планах по 
 использованию ARMv8. Ядра Cortex-A53 и Cortex-A57, поддерживающие ARMv8, 
 были представлены компанией ARM 30 октября 2012 года.[48]

Как AArch32, так и AArch64, поддерживают VFPv3, VFPv4 и advanced SIMD (NEON). 
Также добавлены криптографические инструкции для работы с AES, SHA-1 и SHA-256.

\paragraph{Условное исполнение}

Одним из существенных отличий архитектуры ARM от других архитектур ЦПУ 
является так называемая предикация — возможность условного исполнения команд. 
Под «условным исполнением» здесь понимается то, что команда будет выполнена 
или проигнорирована в зависимости от текущего состояния флагов состояния 
процессора.

В то время как для других архитектур таким свойством, как правило, обладают 
только команды условных переходов, в архитектуру ARM была заложена 
возможность условного исполнения практически любой команды. Это было 
достигнуто добавлением в коды их инструкций особого 4-битового поля 
(предиката). Одно из его значений зарезервировано на то, что инструкция 
должна быть выполнена безусловно, а остальные кодируют то или иное сочетание 
условий (флагов). С одной стороны, с учётом ограниченности общей длины 
инструкции, это сократило число бит, доступных для кодирования смещения в 
командах обращения к памяти, но с другой — позволило избавляться от 
инструкций ветвления при генерации кода для небольших if-блоков.

Пример, обычно рассматриваемый для иллюстрации — основанный на вычитании 
алгоритм Евклида. В языке C он выглядит так:

\begin{lstlisting}[style=cpp,title={алгоритм Евклида}]
while (i != j) {
       if (i > j)
           i -= j;
       else
           j -= i;
}
\end{lstlisting}

А на ассемблере ARM — так:

\begin{lstlisting}[style=asm]
loop CMP Ri, Rj; set condition "NE" if (i != j),
						; "GT" if (i > j),
						; or "LT" if (i < j)
	SUBGT  Ri, Ri, Rj   ; if "GT" (greater than), i = i-j;
	SUBLT  Rj, Rj, Ri   ; if "LT" (less than), j = j-i;
	BNE    loop         ; if "NE" (not equal), then loop
\end{lstlisting}

Из кода видно, что использование предикации позволило полностью избежать 
ветвления в операторах else и then. Заметим, что если Ri и Rj равны, то ни 
одна из SUB инструкций не будет выполнена, полностью убирая необходимость в 
ветке, реализующей проверку while при каждом начале цикла, что могло быть 
реализовано, например, при помощи инструкции SUBLE (меньше либо равно).

Один из способов, которым уплотнённый (Thumb) код достигает большей экономии 
объёма — это именно удаление 4-битового предиката из всех инструкций, кроме 
ветвлений.

\paragraph{Другие особенности}

Другая особенность набора команд это возможность соединять сдвиги и вращения 
в инструкции «обработки информации» (арифметическую, логическую, движение 
регистр-регистр) так, что, например выражение С:
\begin{lstlisting}[style=cpp]
a += (j << 2);
\end{lstlisting}

может быть преобразовано в команду из одного слова и одного цикла в ARM:

\begin{lstlisting}[style=asm]
ADD Ra, Ra, Rj, LSL #2
\end{lstlisting}

Это приводит к тому, что типичные программы ARM становятся плотнее, чем 
обычно, с меньшим доступом к памяти. Таким образом, конвейер используется 
гораздо более эффективно. Даже несмотря на то, что ARM работает на скоростях, 
которые многие бы сочли низкими, он довольно-таки легко конкурирует с 
многими более сложными архитектурами ЦПУ.

ARM процессор также имеет некоторые особенности, редко встречающиеся в 
других архитектурах RISC — такие, как адресация относительно счетчика 
команд (на самом деле счетчик команд ARM является одним из 16 регистров), 
а также пре- и пост-инкрементные режимы адресации.

Другая особенность, которую стоит отметить, это то, что некоторые ранние 
ARM процессоры (до ARM7TDMI), например, не имеют команд для хранения 
2-байтных чисел. Таким образом, строго говоря, для них невозможно 
сгенерировать эффективный код, который бы вел себя так, как ожидается от 
объектов С, типа \verb|volatile int16_t|.

\paragraph{Сопроцессоры}

Архитектура предоставляет способ расширения набора команд, используя 
сопроцессоры, которые могут быть адресованы, используя MCR, MRC, MRRC, 
MCRR и похожие команды. Пространство сопроцессора логически разбито на 16 
сопроцессоров с номерами от 0 до 15, причем 15-й зарезервирован для 
некоторых типичных функций управления, типа управления кэш-памятью и 
операции блока управления памятью (на процессорах, в которых они есть).

В машинах на основе ARM периферийные устройства обычно подсоединяются к 
процессору путем сопоставления их физических регистров в памяти ARM или в 
памяти сопроцессора, или путем присоединения к шинам, которые в свою очередь 
подсоединяются к процессору. Доступ к сопроцессорам имеет большее время 
ожидания, поэтому некоторые периферийные устройства проектируются для 
доступа в обоих направлениях. В остальных случаях разработчики чипов лишь 
пользуются механизмом интеграции сопроцессора. Например, движок обработки 
изображений должен состоять из малого ядра ARM7TDMI, совмещенного с 
сопроцессором, который поддерживает примитивные операции по обработке 
элементарных кодировок HDTV.

\paragraph{Усовершенствованный SIMD (NEON)}

Расширение усовершенствованного SIMD, также называемое технологией NEON — это 
комбинированный 64- и 128-битный набор команд SIMD (single instruction 
multiple data), который обеспечивает стандартизованное ускорение для медиа 
приложений и приложений обработки сигнала. NEON может выполнять декодирование 
аудио формата mp3 на частоте процессора в 10 МГц, и может работать с речевым 
кодеком GSM AMR (adaptive multi-rate) на частоте более 13МГц. Он обладает
 внушительным набором команд, отдельными регистровыми файлами, и независимой 
 системой исполнения на аппаратном уровне. NEON поддерживает 8-, 16-, 32-, 
 64-битную информацию целого типа, одинарной точности и с плавающей запятой, 
 и работает в операциях SIMD по обработке аудио и видео (графика и игры).
  В NEON SIMD поддерживает до 16 операций единовременно.
VFP

\paragraph{Технология VFP}

 (Vector Floating Point, вектора чисел с плавающей запятой) — расширение 
 сопроцессора в архитектуре ARM. Она производит низкозатратные вычисления 
 над числами с плавающей запятой одинарной/двойной точности, в полной мере
  соответствующие стандарту ANSI/IEEE Std 754—1985 Standard for Binary
  Floating-Point Arithmetic. VFP производит вычисления с плавающей запятой, 
  подходящие для широкого спектра приложений — например, для КПК, смартфонов, 
  сжатие звука, трёхмерной графики и цифрового звука, а также принтеров и 
  телеприставок. Архитектура VFP также поддерживает исполнение коротких 
  векторных команд. Но, поскольку процессор выполняет операции 
  последовательно над каждым элементом вектора, то VFP нельзя назвать 
  истинным SIMD набором инструкций. Этот режим может быть полезен в графике 
  и приложениях обработки сигнала, так как он позволяет уменьшить размер кода 
  и выработку команд.

Другие сопроцессоры с плавающей запятой и/или SIMD, находящиеся в ARM 
процессорах включают в себя FPA, FPE, iwMMXt. Они обеспечивают ту же 
функциональность, что и VFP, но не совместимы с ним на уровне опкодов.

\paragraph{Отладка}

Все современные процессоры ARM включают аппаратные средства отладки, так как 
без них отладчики ПО не смогли бы выполнить самые базовые операции типа 
остановки, отступа, установка контрольных точек после перезагрузки.

Архитектура ARMv7 определяет базовые средства отладки на архитектурном 
уровне. К ним относятся точки останова, точки просмотра и выполнение команд 
в режиме отладки. Такие средства были также доступны с модулем отладки 
EmbeddedICE. Поддерживаются оба режима — остановки и обзора. Реальный 
транспортный механизм, который используется для доступа к средствам отладки, 
не специфицирован архитектурно, но реализация, как правило, включает 
поддержку \jtag.

Существует отдельная архитектура отладки «с обзором ядра», которая не 
требуется архитектурно процессорами ARMv7.

\paragraph{Регистры}

ARM предоставляет 31 регистр общего назначения разрядностью 32 бит. 
В зависимости от режима и состояния процессора пользователь имеет доступ 
только к строго определённому набору регистров. В ARM state разработчику 
постоянно доступны 17 регистров:

\begin{itemize}
\item 13 регистров общего назначения (\R{0}..\R{12}).
\item Stack Pointer (\R{13}) — содержит указатель стека выполняемой программы.
\item Link register (\R{14}) — содержит адрес возврата в инструкциях ветвления.
\item Program Counter (\R{15}) — биты [31:1] содержат адрес выполняемой инструкции.
\item Current Program Status Register (\R{CPSR}) — содержит флаги, о
писывающие текущее состояние процессора. Модифицируется при выполнении 
многих инструкций: логических, арифметических, и др.
\end{itemize}

Во всех режимах, кроме User mode и System mode, доступен также Saved 
Program Status Register (\Reg{SPSR}). После возникновения исключения регистр 
\Reg{CPSR}\ сохраняется в \Reg{SPSR}. Тем самым фиксируется состояние процессора (режим, 
состояние; флаги арифметических, логических операций, разрешения прерываний) 
на момент непосредственно перед прерыванием.
