\chapter{Архитектура ARM}

\cp{\url{http://ru.wikipedia.org/wiki/ARM}} %\_(архитектура)

Архитектура ARM (Advanced RISC Machine, Acorn RISC Machine, 
усовершенствованная RISC-машина)\ --- семейство лицензируемых 32-битных и 
64-битных микропроцессорных ядер разработки компании ARM Limited.

Среди лицензиатов: практически все заметные разработчики цифровых
электронных компонентов.
Многие лицензиаты делают собственные версии ядер на базе ARM.

Значимые семейства процессоров: ARM7, ARM9, ARM11 и Cortex.

В 2007 году около 98\% из более чем миллиарда мобильных телефонов, продаваемых 
ежегодно, были оснащены по крайней мере одним процессором ARM. По состоянию 
на 2009 на процессоры ARM приходилось до 90\% всех встроенных 32-разрядных 
процессоров. Процессоры ARM широко используются в потребительской 
электронике\ --- в том числе КПК, мобильных телефонах, цифровых носителях и 
плеерах, портативных игровых консолях, калькуляторах и компьютерных п
ериферийных устройствах, таких как жесткие диски или маршрутизаторы.

Эти процессоры имеют низкое энергопотребление, поэтому находят широкое 
применение во встраиваемых системах и преобладают на рынке мобильных 
устройств, для которых данный фактор немаловажен.

В настоящее время значимыми являются несколько семейств процессоров ARM:

\begin{itemize}
\item ARM7 (с тактовой частотой до 60-72 МГц), предназначенные, например, для 
недорогих мобильных телефонов и встраиваемых решений средней производительности. 
В настоящее время активно вытесняется новым семейством Cortex.
\item ARM9, ARM11 (с частотами до 1 ГГц) для продвинутых телефонов, карманных 
компьютеров и встраиваемых решений высокой производительности.
\item Cortex A\ --- новое семейство процессоров на смену ARM9 и ARM11.
\item Cortex M\ --- новое семейство процессоров на смену ARM7, также 
призванное занять новую для ARM нишу встраиваемых решений низкой 
производительности. В семействе присутствуют три значимых ядра: \cm{0}, 
\cm{3} и \cm{4}.
\end{itemize}

\paragraph{Архитектура}

Существует спецификация архитектуры ARM Cortex, которая разграничивает все типы опций, 
которые поддерживает ARM, так как детали реализации каждого типа процессора м
огут отличаться. Архитектура развивалась с течением времени, и начиная с 
ARMv7 были определены 3 профиля:
\begin{itemize}
\item{A (application)} для устройств, требующих высокой производительности (смартфоны, планшеты)
\item{R (real time)} для приложений, работающих в реальном времени,
\item{M (microcontroller)} для микроконтроллеров и недорогих встраиваемых устройств.
\end{itemize}

\paragraph{Режимы процессора}

Процессор может находиться в одном из следующих рабочих режимов:
\begin{itemize}
\item{User mode} — обычный режим выполнения программ. В этом режиме 
выполняется большинство программ.
\item{Fast Interrupt (FIQ)} — режим быстрого прерывания (меньшее время с
рабатывания)
\item{Interrupt (IRQ)} — основной режим прерывания.
\item{System mode} — защищённый режим для использования операционной системой.
\item{Abort mode} — режим, в который процессор переходит при возникновении 
ошибки доступа к памяти (доступ к данным или к инструкции на этапе 
prefetch конвейера).
\item{Supervisor mode} — привилегированный пользовательский режим.
\item{Undefined mode} — режим, в который процессор входит при попытке 
выполнить неизвестную ему инструкцию.
\end{itemize}

Переключение режима процессора происходит при возникновении соответствующего 
исключения, или же модификацией регистра статуса.

\paragraph{Набор команд ARM}

Режим, в котором исполняется 32-битный набор команд.

\paragraph{Набор команд \thmod}

Для улучшения плотности кода процессоры, начиная с ARM7TDMI, снабжены режимом 
\thmod. В этом режиме процессор выполняет альтернативный набор 16-битных 
команд. Большинство из этих 16-разрядных команд переводятся в нормальные 
команды ARM. Уменьшение длины команды достигается за счет сокрытия некоторых 
операндов и ограничения возможностей адресации по сравнению с режимом полного 
набора команд ARM.

В режиме \thmod\ меньшие коды операций обладают меньшей функциональностью. 
Например, только ветвления могут быть условными, и многие коды операций имеют 
ограничение на доступ только к половине главных регистров процессора. Более 
короткие коды операций в целом дают большую плотность кода, хотя некоторые 
операции требуют дополнительных команд. В ситуациях, когда порт памяти или 
ширина шины ограничены 16 битами, более короткие коды операций режима 
\thmod\ становятся гораздо производительнее по сравнению с обычным 32-битным ARM 
кодом, так как меньший программный код придется загружать в процессор при 
ограниченной пропускной способности памяти.

Аппаратные средства типа Game Boy Advance, как правило, имеют небольшой объём 
оперативной памяти доступной с полным 32-битным информационным каналом. Но 
большинство операций выполняется через 16-битный или более узкий информационный 
канал. В этом случае имеет смысл использовать \thmod\ код и вручную 
оптимизировать некоторые тяжелые участки кода, используя переключение в 
режим \armod.

\paragraph{Набор команд \thmod2}

\thmod2 — технология, стартовавшая с ARM1156 core, анонсированного в 2003 
году. Он расширяет ограниченный 16-битный набор команд Thumb дополнительными 
32-битными командами, чтобы задать набору команд дополнительную ширину. Цель 
\thmod2\ --- достичь плотности кода как у Thumb, и производительности как у 
набора команд \armod\ на 32 битах. Можно сказать, что в ARMv7 эта цель была 
достигнута.

\thmod2 расширяет как команды \armod, так и команды \thmod\ ещё большим 
количеством команд, включая управление битовым полем, табличное ветвление, 
условное исполнение. Новый язык «Unified Assembly Language» (UAL) поддерживает 
создание команд как для ARM, так и для Thumb из одного и того же исходного 
кода. Версии \thmod\ на ARMv7 выглядят как код ARM. Это требует осторожности и 
использования новой команды if-then, которая поддерживает исполнение до 4 
последовательных команд испытываемого состояния. Во время компиляции в ARM 
код она игнорируется, но во время компиляции в код \thmod2 генерирует команды.

\paragraph{Набор команд Jazelle}

Jazelle — это технология, которая позволяет байткоду Java исполняться прямо 
в архитектуре ARM в качестве 3-го состояния исполнения (и набора команд) 
наряду с обычными командами ARM и режимом Thumb. Поддержка технологии Jazelle 
обозначается буквой «J» в названии процессора — например, ARMv5TEJ. Данная 
технология поддерживается начиная с архитектуры ARMv6, хотя новые ядра 
содержат лишь ограниченные реализации, которые не поддерживают аппаратного 
ускорения.

\paragraph{ARMv8 и набор команд ARM 64 бит}

В конце 2011 года была опубликована новая версия архитектуры, ARMv8. В ней 
появилось определение архитектуры AArch64, в которой исполняется 64-битный 
набор команд A64. Поддержка 32-битных команд получила название A32 и
 исполняется на архитектурах AArch32. Инструкции Thumb поддерживаются в 
 режиме T32, только при использовании 32-битных архитектур. Допускается 
 исполнение 32-битных приложений в 64-битной ОС, и запуск виртуализованной 
 32-битной ОС при помощи 64-битного гипервизора.[47] Applied Micro, AMD, 
 Broadcom, Calxeda, HiSilicon, Samsung, STM и другие заявили о планах по 
 использованию ARMv8. Ядра Cortex-A53 и Cortex-A57, поддерживающие ARMv8, 
 были представлены компанией ARM 30 октября 2012 года.[48]

Как AArch32, так и AArch64, поддерживают VFPv3, VFPv4 и advanced SIMD (NEON). 
Также добавлены криптографические инструкции для работы с AES, SHA-1 и SHA-256.

\paragraph{Условное исполнение}

Одним из существенных отличий архитектуры ARM от других архитектур ЦПУ 
является так называемая предикация — возможность условного исполнения команд. 
Под «условным исполнением» здесь понимается то, что команда будет выполнена 
или проигнорирована в зависимости от текущего состояния флагов состояния 
процессора.

В то время как для других архитектур таким свойством, как правило, обладают 
только команды условных переходов, в архитектуру ARM была заложена 
возможность условного исполнения практически любой команды. Это было 
достигнуто добавлением в коды их инструкций особого 4-битового поля 
(предиката). Одно из его значений зарезервировано на то, что инструкция 
должна быть выполнена безусловно, а остальные кодируют то или иное сочетание 
условий (флагов). С одной стороны, с учётом ограниченности общей длины 
инструкции, это сократило число бит, доступных для кодирования смещения в 
командах обращения к памяти, но с другой — позволило избавляться от 
инструкций ветвления при генерации кода для небольших if-блоков.

Пример, обычно рассматриваемый для иллюстрации — основанный на вычитании 
алгоритм Евклида. В языке C он выглядит так:

\begin{lstlisting}[style=cpp,title={алгоритм Евклида}]
while (i != j) {
       if (i > j)
           i -= j;
       else
           j -= i;
}
\end{lstlisting}

А на ассемблере ARM — так:

\begin{lstlisting}[style=asm]
loop CMP Ri, Rj; set condition "NE" if (i != j),
						; "GT" if (i > j),
						; or "LT" if (i < j)
	SUBGT  Ri, Ri, Rj   ; if "GT" (greater than), i = i-j;
	SUBLT  Rj, Rj, Ri   ; if "LT" (less than), j = j-i;
	BNE    loop         ; if "NE" (not equal), then loop
\end{lstlisting}

Из кода видно, что использование предикации позволило полностью избежать 
ветвления в операторах else и then. Заметим, что если Ri и Rj равны, то ни 
одна из SUB инструкций не будет выполнена, полностью убирая необходимость в 
ветке, реализующей проверку while при каждом начале цикла, что могло быть 
реализовано, например, при помощи инструкции SUBLE (меньше либо равно).

Один из способов, которым уплотнённый (Thumb) код достигает большей экономии 
объёма — это именно удаление 4-битового предиката из всех инструкций, кроме 
ветвлений.

\paragraph{Другие особенности}

Другая особенность набора команд это возможность соединять сдвиги и вращения 
в инструкции «обработки информации» (арифметическую, логическую, движение 
регистр-регистр) так, что, например выражение С:
\begin{lstlisting}[style=cpp]
a += (j << 2);
\end{lstlisting}

может быть преобразовано в команду из одного слова и одного цикла в ARM:

\begin{lstlisting}[style=asm]
ADD Ra, Ra, Rj, LSL #2
\end{lstlisting}

Это приводит к тому, что типичные программы ARM становятся плотнее, чем 
обычно, с меньшим доступом к памяти. Таким образом, конвейер используется 
гораздо более эффективно. Даже несмотря на то, что ARM работает на скоростях, 
которые многие бы сочли низкими, он довольно-таки легко конкурирует с 
многими более сложными архитектурами ЦПУ.

ARM процессор также имеет некоторые особенности, редко встречающиеся в 
других архитектурах RISC — такие, как адресация относительно счетчика 
команд (на самом деле счетчик команд ARM является одним из 16 регистров), 
а также пре- и пост-инкрементные режимы адресации.

Другая особенность, которую стоит отметить, это то, что некоторые ранние 
ARM процессоры (до ARM7TDMI), например, не имеют команд для хранения 
2-байтных чисел. Таким образом, строго говоря, для них невозможно 
сгенерировать эффективный код, который бы вел себя так, как ожидается от 
объектов С, типа \verb|volatile int16_t|.

